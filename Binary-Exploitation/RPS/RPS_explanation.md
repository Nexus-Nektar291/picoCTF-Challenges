# Challenge Name: RPS

## ğŸ§  Code Analysis

```c
bool play()
{
  char player_turn[100];
  srand(time(0));
  int r;

  printf("Please make your selection (rock/paper/scissors):\n");
  r = tgetinput(player_turn, 100);
  // Timeout on user input
  if (r == -3)
  {
    printf("Goodbye!\n");
    exit(0);
  }

  int computer_turn = rand() % 3;
  printf("You played: %s\n", player_turn);
  printf("The computer played: %s\n", hands[computer_turn]);

  if (strstr(player_turn, loses[computer_turn]))
  {
    puts("You win! Play again?");
    return true;
  }
  else
  {
    puts("Seems like you didn't win this time. Play again?");
    return false;
  }
}
```

## ğŸ•µï¸ Vulnerability Explanation

The program determines whether the player has won using the following line:

```c
if (strstr(player_turn, loses[computer_turn]))
```

This line checks if the player's input contains the string that loses to the computer's move.  
It uses `strstr()` which only checks for **substring presence**, not exact equality.  
This is a **logic bug** â€” if the player's input **includes** the losing string, it counts as a win, regardless of what they actually meant to play.

---

## ğŸ’¥ Exploitation Strategy

To abuse this flaw, simply input:

```
rockpaperscissor
```

This string includes all three possible hand choices:
- rock
- paper
- scissors

So, no matter what the computer chooses, `strstr(player_turn, loses[computer_turn])` will always be **true**, resulting in a guaranteed **win** every time.

---

## âœ… Conclusion

This is a logic vulnerability caused by incorrect string matching.  
It demonstrates why input validation and exact comparison (like `strcmp()`) are crucial in game logic or any kind of conditional checks.
